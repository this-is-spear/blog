---
title: key-value storage 동작 방식 정리
date: '2025-01-24'
tags: ['개념']
draft: false
summary: 간단한 구조에서 부족한 부분을 보완하면서 동작 이유 정리해보기
images: []
---

### Introduction

<TOCInline toc={props.toc} exclude="Introduction" />

### 개요

키-밸류 스토리지 동작을 부족한 부분을 해결하는 방식으로 정리했다.

### 기본 동작부터 추가 기능까지 정리

저장소를 설계한다면 영속화를 고려한다.
영속화하는 경우 데이터는 다음처럼 파일에 기록된다.

![images](/static/images/study/key-value-storage/1.png)

특정 `key`의 `value`를 수정한다면 다음처럼 파일에 기록된다.

![images](/static/images/study/key-value-storage/2.png)

데이터 변경마다 파일을 읽고 작성하는 작업은 부담이다.
다음처럼 파일 끝부분에 데이터를 계속 추가하고 제일 최신에 저장된 `key-value`를 참조한다면 파일을 읽고 쓰는 작업을 줄일 수 있다.

![images](/static/images/study/key-value-storage/3.png)

작성마다 파일에 데이터를 추가하는 건 다음 단점이 있다.

- 데이터가 계속 추가되므로 디스크 요구 용량이 늘어난다.
- 파일을 작성하는 작업을 동기화해야 한다.

이런 단점을 보완하기 위해 LSM 트리를 사용한다.
LSM 트리는 `Log-Structured Merge-Tree`의 약자로 디스크에 데이터를 저장하는 방법과 구조를 의미한다.

![images](/static/images/study/key-value-storage/4.png)

간단하게 과정을 설명한다.

1. `Memtable`에 데이터를 저장한다.
2. `Memtable`이 꽉 차면 `SSTable`로 변환한다.

`Memtable`과 `SSTable`은 다음 특징을 가진다.

- `Memtable`
    - 메모리에 저장되는 데이터 구조로 `key-value`를 저장한다.
    - 탐색이 쉬운 구조로 `key`를 정렬해 저장한다. 보통 이진 트리로 저장하며 self balancing 특징을 가진다.
- `SSTable`
    - `Sorted String Table`의 약자로 정렬된 문자열 테이블을 의미하며 디스크에 저장되는 단위다.
    - 동시성을 고려해 `SSTable`은 불변성을 가진다.

이후 `SSTable`이 여러개 모이면 단계적으로 컴팩션을 진행한다.

![images](/static/images/study/key-value-storage/5.png)

디스크 요구 용량을 줄일 수 있다.

> 이떄 컴팩션은 단계적으로 진행된다. L1, L2, L3 단계로 나눠져서 모일떄마다 다음 단계로 이동한다.
> 불변성을 깨드리지 않기 위해 단계적으로 진행하는 모습처럼 보인다.(JVM GC survivor1, survivor2 방식처럼 새로운 영역에다 데이터를 옮기는 방식처럼 말이다.)

덕분에 다음 문제점을 해결한다.

- 디스크 요구 용량이 늘어난다. : `SSTable`을 단계적으로 컴팩션한다.
- 파일 접근 영역 동기화해야 한다. : `Memtable`에서 `SSTable` 생성하는건 작업자 한 명으로 충분하다.

쓰기 관련 이슈는 전부 해결했지만 조회가 어렵다.
단계적으로 저장된 `SSTable`을 모두 조회하는 문제가 발생한다.

이를 해결하기 위해 `Bloom Filter`를 사용한다.

![images](/static/images/study/key-value-storage/6.png)

해당 키가 존재하는지 다음 방식으로 확인하면 된다고 생가하는데 `틀렸다.`

1. `Bloom Filter`에 `key`에 맞는 일부 영역을 마킹한다.
2. `key`가 존재하는지 확인할 때 `Bloom Filter`에 동일한 영역이 마킹된지 확인한다.

그림처럼 다른 키로 인해 칠해져있을 가능성이 있기 때문이다.
사용하는 이유는 해당 키가 존재하지 않음을 확실하게 알 수 있는 방식을 활용하기 위해서다.

**만약 해당 키가 마킹돼있다면 키가 존재할 가능성이 있으니 키를 찾으러 떠나야 한다.**
완벽한 정답은 아니다. 그러나 `Bloom Filter`를 사용하면 조회 성능 최적화가 가능하다.

> `Bloom Filter`에 사용할 마킹 영역 넓이에 따라 결과 정확도가 달라진다.
> 그러나 마킹 영역이 넓어진다는건 마킹할 시간이 늘어난다는 의미니 주의해야 한다.
