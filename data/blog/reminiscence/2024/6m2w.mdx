---
title: 6월 2주 있었던 일 정리
date: '2024-06-16'
tags: ['회고', 'tidy first']
draft: false
summary: 책 읽고 정리
images: []
---
## Introduction

<TOCInline toc={props.toc} exclude="Introduction" />

# Tidy First?

## 서론

대부분의 소프트웨어 설계자는 설계 자체가 시간을 초월해서 이뤄지는 것처럼 행동하지만 실제로는 시간에 따라 변화하게 된다.
설계와 관련된 조언은 많지만 실제 사례에서 모순만 드러나는 경우가 많다.
책에서는 설계를 구성할 수 있는 환경 만드는 일에 집중한다. 그래서 환경을 만드는 경험에 기반한 소프트웨어 설계의 중요성을 강조한다.

개발 이론은 독자의 난이도를 고려해 시간 변수를 무시한 체 설명하기 때문에 실무에 적용하려면 이론과 현실 사이의 괴리감을 직접 경험해볼 필요가 있다.
`해봤어?`, `백문이불여일타` 라고 물어보는 이유는 괴리감을 줄여 이상에 가까운 환경을 만드는게 목적이다.
책 이름이 `깔끔함이 먼저다(Tidy First)`인 이유는 실천 가능한 코드 정리에서 시작해 모순을 제거하며 이론에 가까운 환경을 만들 수 있도록 도와주기 위함이라 생각한다.

책을 읽으면 `시스템 동작 변경`과 `시스템 구조 변경`의 근본적인 차이점을 알 수 있다고 한다.
두 개에 차이는 사소하지 않다는 의미다.
주말동안 코드 정리 파트만 읽고 와닿거나 알게된 내용을 추렸다.

## PART1 : 코드 정리

### **CHAPTER 10 : 명시적인 매개변수**

처음에는 `컬렉션을 넘겨 일부만 사용하거나 제거하는 상황`을 의미하는가 했는데 `DTO를 사용해 사용하는 매개변수를 모호하게 만드는 상황`을 겨냥하는 말일 수 있겠다는 생각도 들었다.
결국 결합도를 줄이려면 모호하지 않은 변수는 받지 않아야 한다. 명확한 매개변수로 사전 조건을 만들어 견고한 코드를 지향할 수 있다.

처음에는 `컬렉션을 넘겨 일부만 사용하거나 제거하는 상황`을 의미하는가 했는데 `DTO를 사용해 사용하는 매개변수를 모호하게 만드는 상황`을 겨냥하는 말일 수 있겠다는 생각도 들었다.
결국 결합도를 줄이려면 모호하지 않은 변수는 받지 않아야 한다. 명확한 매개변수로 사전 조건을 만들어 견고한 코드를 지향할 수 있다.

### **CHAPTER 11 : 비슷한 코드끼리 &** CHAPTER 12 : 도우미 추출 방법

긴 코드 라인을 가진 메서드가 있다면 비슷한 코드끼리 구분하기 위해서 개행(`\n`) 문자를 추가한다.
이 방식은 가장 간단하기 때문에 적극적으로 활용하길 추천한다.
복리처럼 뒤따르는 유연성을 모아 재설계할 수 있는 힘을 기를 수 있다.
책에서는 대표적으로 변수로 추출하거나 메서드로 추출하는 방법으로 응집도를 개선한다.

메서드로 추출하는 방법은 `CHAPTER 12 : 도우미 추출 방법`이라 해서 응집도 높은 요소 만들어 나가는 방법이다.
예로는 `시간적 결합`을 표현하기 위해서 사용하기도 한다.

필자는 보통 변수의 생명주기를 고려해 메서드를 추출하게 되는데, 비슷한 코드끼리 묶여있기 때문에 가능하다고 생각한다.
개행으로 그룹핑하는 건 간단하고 좋은 방법이다. 별개로 사용 목적으로 기준으로 도우미 추출하는 방식은 접근하기 어려웠다.
사용 목적에 따라 추출한다니 유틸 메서드를 만드는 느낌이라 조심스럽다.

### **CHAPTER 13 : 하나의 더미**

필요한 만큼 하나의 더미처럼 느껴질 때까지 코드를 모은 후 정리한다.
코드를 만드는 데 가장 큰 비용은 읽고 이해하는 일이다.
코드를 모은 후 정리하게 되면 응집도를 높일 수 있는 길을 제시할 수 있다.
보통 다음 증상이 나타나면 고민해볼만 하다.

- 길고 반복되는 인자 목록
- 반복되는 코드, 반복되는 조건문
- 도우미에 대한 목적이 명확하지 않은 이름
- 공유되면서 변경에 노출된 데이터 구조

최근에 엑셀 파일 생성 로직을 일원화한 경험이 있다.
동일한 패턴을 모으고 동일하지 않은 패턴은 응집도에 따라 각자 관리하거나 메서드로 사용 할 수 있도록 정리하며 객체로 만들었다.
엑셀 파일이 생성될때마다 객체를 재사용하면서 코드 작성하는 일이 꽤나 간편해졌다.

### **CHAPTER 15 : 불필요한 주석 지우기**

> 주석과 코드는 작성할 때와 나중에 볼 때 시간이 흐르고 나면 서로 맞지 않는 경우가 있다.

문서화로 고통받고 있다면 공감할 내용이다. 이전 이력이 남아 관리하기 어려워지는 순간이 있는데 과감하게 제거할 필요가 있다.
그래서 작업하기 전 문서와 작업 후 문서를 나눠 문서를 관리하고 작업하기 전 문서는 작업이 끝나면 한 곳에 모아 관리하고 있다.

## PART2 : 관리

### **CHAPTER 18** : 코드 정리의 일괄 처리량

배포하기 전 코드를 일괄 정리한 양에 따라 복잡도가 올라간다.
일괄 정리한 코드 정리 작업이 많을 수록 통합 과정에서 지연 시간이 길어지고 충돌 가능성이 커진다.
또한 코드 정리 사이 상호작용이 있으면 병합 비용은 증가한다.
일괄 처리 규모를 축소해 검토 비용을 줄이고 지속적으로 통합하는게 비용을 줄일 수 있는 길이다.

일부 회사는 PR 양을 최소화하고 양이 크다면 사유를 써야 했다.
지금 든 생각은 일괄 처리로 인한 검토 비용을 경계 했다고 생각한다.

### **CHAPTER 19 : 리듬**

구조 변경에 한 시간 이상 소요한다면 최소한의 구조 변경 시기를 놓친 것이다.
파레토 법칙에 따르면 변경 사항은 20% 범위 내에서만 발생한다.
그럼 변경한 내용들은 계속해서 수정된다.
그럼 변경 사항이 오래 남을 수 없게된다.

소프트웨어 설계는 길을 닦는 과정이며 변경한 내용은 누군가 지나가면서 없어질 가능성이 높으니 **한 번의 구조 변경에 오랜 시간을 투자하지 말자.**
**동작 변경 사이마다 구조 변경을 진행하며 누군가가 쉽게 지나갈 수 있을만큼만 정리하자.**

## 결론

모든 이야기가 단순한 만큼 가고자하는 길이 명확하다.

### 시간 변수는 괴리를 만든다.

개발하면서 프로젝트를 구상할 때 시간 변수를 제외하고 고민하는 건 위험한 일이었다.
당장 코딩 테스트만 해도 의사 코드만 작성하지 시간 변수에 변화를 고려하지 않는다.
업무에서 이론과 실무 사이 괴리로 당혹스러운 코드 수정이 많았는데, 책을 읽고 당혹스로운 원인을 명시할 수 있었다.

### 명시적이어야 한다.

이펙티브 테스트 책을 읽고 코드 흐름을 테스트로 제어할 수 있음을 확신할 수 있었다.
사전 사후 검사로 메서드 안에서 흐름을 제어하고 명세 테스트 구조 테스트를 이용해 작업 진행 중 테스트로 흐름을 제어할 수 있다.

책에서는 포켓몬 게임을 하듯이 진행해보는게 어떤지 물어보면서 굳이 멋진 단어로 하고자 하는 말을 치장할 필요가 없음을 느꼈다.
공감은 이해해서 시작한다. 나도 이런 멋진 책을 써보고 싶다.
