---
title: 2월 3주 있었던 일 정리
date: '2024-02-25'
tags: ['회고', '동시성']
draft: false
summary:
images: []
---

## Introduction

<TOCInline toc={props.toc} exclude="Introduction" />

## 원자성을 보장해야 하는 이유

우리는 흔히 사용자의 요청을 받아 비즈니스를 처리하게 되는 멀티스레딩 환경 서버를 관리하게 된다.
멀티 스레딩 환경에서 공유 데이터에 다수 작업이 접근하면 데이터가 훼손된 다는 것을 예상 할 수 있다.
그 이유는 작업의 `원자성`을 보장해줄 수 없기 때문이다.

이런 케이스는 영역마다 다양하게 존재한다. `애플리케이션 레벨`에서도 발생할 수 있고, `명령어 레벨`에서도 발생할 수 있다. 물론 `시스템 레벨`에서도 발생 할 수 있다.

| 애플리케이션 레벨                                              | 명령어 레벨                                                 |
|--------------------------------------------------------|--------------------------------------------------------|
| ![images](/static/images/reminiscence/2024/2m3w/1.png) | ![images](/static/images/reminiscence/2024/2m3w/2.png) |


이런 문제는 실제 환경에서 자주 발생한다. 우린 아래와 같은 상황을 한 번씩 맞딱뜨려 봤을테다.

![images](/static/images/reminiscence/2024/2m3w/3.png)

발생하는 문제가 문제 파악 과 문제 해결 간에 누군가 요청해서 동일한 작업을 하게되는게 문제다.
이런 경우 문제 파악부터 해결까지 원자성을 보장해줄 수 있어야 한다.
그렇다고 문제 파악과 동시에 문제 해결을 할 수 없다.
그래서 문제 파악부터 해결까지 원자성을 보장해줄 수 있도록 임계 영역을 구성해두고 혼자만 작업 할 수 있게 만드는 일이 중요하다.

![images](/static/images/reminiscence/2024/2m3w/4.png)

## 원자성을 보장하기 위한 방법

결국 어떤 상황에서도 임계 영역만 구성한다면 `원자성`을 보장해 줄 수 있다.
우리는 왜 `원자성`을 보장해야하는지 이해하게 됐다. 그럼 `원자성`을 보장하기 위해 상호 배제 방법을 알아볼 차례다.

상호배제는 다음처럼 구성할 수 있다. 하지만 우리가 원하는대로 수행하지 않는다.
그 이유는 **코드로 작성된 명령어는 원자성을 보장하지 않기 때문이다.**

![images](/static/images/reminiscence/2024/2m3w/5.png)

첫 번 째 문제는 우리가 작성한 `entry code`에서 발생하게 된다.

| 상호 배제 과정도 결국 상호 배제가 되어야 한다.                            | 상호 배제 과정 도중 인터럽트가 발생하면 안된다.                            |
|--------------------------------------------------------|--------------------------------------------------------|
| ![images](/static/images/reminiscence/2024/2m3w/8.png) | ![images](/static/images/reminiscence/2024/2m3w/9.png) |

특히나 이 문제는 `instruction pipeline`으로 인해 빈번하게 발생한다.
CPU는 실행이 멈추지 않도록 명렁어 순서를 조정하면서 조회 명령어를 먼저 수행하게 된다.
즉, 아무리 명령어를 순차적으로 보낸다고 해도 결국 CPU 결정에 의해 명령어 순서가 변경되니 신경써야 한다.

![images](/static/images/reminiscence/2024/2m3w/7.png)

그래서 원자 명령을 이용해 상호 배제에 성공 할 수 있어야 한다. 즉, `락 비교` + `락 획득`이 한 번에 발생해야 한다.

![images](/static/images/reminiscence/2024/2m3w/10.png)

결국 원자 명령을 제공하는 명령어를 사용해 상호 배제 공간을 획득한 뒤 데이터 훼손 문제를 적절하게 해결 할 수 있다.

서비스도 명령어 레벨에서 제어하는 방법과 다를게 없다. `하나의 비즈니스 로직이 원자성을 보장하면 된다.` 그런데 원자성의 영역에 따라 시스템의 성능 차이가 발생한다.

동기화를 하게 되면 데이터 훼손 문제는 발생하지 않지만 운영체제가 정의한 작업 우선순위를 무시하고 대기중인 작업을 순차적으로 실행하게 되어 리소스를 효율적으로 사용하지 않게 되어 버린다.

우리는 데이터 훼손 문제를 방지하기 위해서 결국 임계 영역의 범위를 최소화해야 한다.
만약 하나의 데이터를 여러 스레드가 사용하는게 문제라면 데이터를 수정하는 영역만 임계 영역을 구성하고, 비즈니스 로직에 맞게 조회한 다음 여러 데이터를 접근한다면 비즈니스 로직에 임계영역을 구성해야 한다.

| 임계 영역 범위 | 비즈니스 로직                                                 | 데이터 접근                                                  |
|----------|---------------------------------------------------------|---------------------------------------------------------|
| 그림       | ![images](/static/images/reminiscence/2024/2m3w/11.png) | ![images](/static/images/reminiscence/2024/2m3w/12.png) |


