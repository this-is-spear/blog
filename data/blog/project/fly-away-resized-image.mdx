---
title: 쉽고 빠른 이미지 관리
date: '2023-11-19'
tags: ['프로젝트', '회고']
draft: false
summary: 이미지 리사이징 프로젝트 회고
images: []
---

## 리사이즈된 이미지 전달 서비스

### 계기

프론트엔드 팀은 이미지 관리 문제로 고충을 겪고 있더라구.
마침 사이드 프로젝트로 여러 기술을 사용하고 싶었고, 관리 문제를 해결 할 수 있어보여서 도와주기로 했어!

프론트엔드 팀은 리사이즈 된 이미지, 압축된 이미지, 크롭한 이미지를 적재적소에 사용해야 하는데 많은 이미지를 어떻게 관리할지 고민하고 있었어.
저장-관리 비용을 생각했을 때 `webp`, `png` 등으로 관리하고 최소 2 개 이상의 사이즈를 사용한다면 비용이 대략 `N^3` 사이즈가 필요하다고 생각 할 수 있지.

![그림 2](/static/images/project/fly-away-resized-image/2.png)

조금 더 세밀하게 따져볼까?
대략 한 달에 500개 정도의 이미지를 업데이트한다고 생각하고.
이미지는 평균 3MB 라고 생각해보자.

요청 1000회당 0.0045 USD 면 연간 0.027 USD 이라는 비용이 발생 해.

![그림 2](/static/images/project/fly-away-resized-image/4.png)

리사이즈된 친구들은 보통 압축되어 작은 사이즈로 만들어져.
리사이즈된 친구들을 모두 모은 크기가 원본 사이즈랑 동일하다고 생각해볼게.
그럼 6,000 * 6MB 이니 연간 36GB 데이터가 필요하지. 0.0024 * 36 = 0.0864 USD 가 필요해.

![그림 2](/static/images/project/fly-away-resized-image/5.png)

계산해보면 연간 대략 0.1 USD 가 필요해. 생각보다 사이즈가 안되니 비용 측면에서는 전혀 신경쓸 일이 없어.

가장 무서운 건 저장소에는 데이터가 계속 쌓인다는 점이야.
특정한 이미지를 삭제하려면 관련된 이미지도 삭제해야 하는데 이런 부분을 관리하기가 되게 까다로워.

![그림 2](/static/images/project/fly-away-resized-image/3.png)

### 프론트 입장에서 생각해보자.

업무를 하면서 코드 없이 문제를 해결하는게 가장 베스트라는 걸 몸소 깨달았지.
어떻게 하면 코드를 멋지게 짤지 고민하는 것도 재밌지만 성과가 나오는게 재밌더라구. (내가 생각하는 성과는 누군가에게 도움이 **된** 일이라고 생각해.)
그래서 어떻게 하면 빠르게 문제를 해결할지 고민을 많이 하고 있어.

이번에는 나의 생각을 관철 해보려고 프론트엔드 팀 분들에게 이것저것 물어봤어.
특히나 만들면 바로 사용할 수 있는지를 물어봤어.
열심히 노력한게 사용 안되면 슬플 것 겉거든... 흑흑

그래서 알게 된 건 이해관계자들과의 협의가 필요하다는 점이었어.
그래서 원활한 소통이 될 수 있도록 샘플을 만들면 좋겠다고 생각했고 빠른 개발이 중요하게 됐어.

그래서 테스트 코드 없는 기능이 일주일 만에 탄생하게 됐어. ㅋㅋㅋ

### 계획 1 - 리사이즈 기능은 어떻게 구현하지?

다른 팀은 어떻게 이 문제를 해결 했을까라는 생각이 문득 스쳤어.
당근 마켓에서는 [람다를 활용한 이미지 리사이즈](https://medium.com/daangn/aws-lambda%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EC%83%9D%EC%84%B1-%EA%B0%9C%EB%B0%9C-%ED%9B%84%EA%B8%B0-acc278d49980)를 통해 이미지 저장 비용과 관리 비용을 줄였어.

람다를 활용하면 서버 관리 비용을 줄이는 데 획기적이겠더라구!!
하지만 기능 추가에는 꽤나 많은 공을 들일 듯 했어.
코드들이 기능 추가에 유연하지 않았고 테스트 코드가 없는게 문제였지.

이미지 추가, 삭제, 리스트 조회 등의 UI 도 필요해보였어.
그래서 서버 관리 비용을 들이더라도 기능 추가가 쉬운게 베스트라고 생각했어.

### 계획 2 - s3 접근 비용은 캐시 레이어로 해결 할 수 있어보여.

당근 마켓은 [`on-the-fly` 전달 방식](https://medium.com/daangn/lambda-edge%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-on-the-fly-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-f4e5052d49f3)을 활용해 s3 접근 비용도 줄여나갔지.
좋은 방법이었어!

하지만 `cdn`을 사용하면 외부에 의존적인 문제와 비용이 든다는 문제가 있었지.
또한 `cdn`에 없으면 `client`는 `server`에게 리사이즈 요청을 하고 `cdn`에 저장할 때까지 기다린다음 재 요청해야 했어.
그런 흐름이 프론트 팀의 개발을 복잡하게 만들 수 있어보였어.

```mermaid
sequenceDiagram
    actor client
    client --> cdn: image
    cdn --> client: no
    client --> server: resize
    server --> cdn: save
    server --> client: ok
    client --> cdn: image
    cnd --> client: ok
```

그래서 직접 구현하기로 했어.
`nginx`가 정적 리소스 캐싱과 관련된 내용이 많았지만 `nginx`에 대해서 몰라서 러닝 커브가 컸어.
그래서 최근에 학습한 스프링 클라우드 게이트웨이를 활용해보려해!

스프링 클라우드 게이트웨이가 4.x 버전으로 올라오면서 캐시 레이어를 추가했거든!!
요즘 개발 트렌드가 어떻게 흘러가는지 확인하려고 최신 버전들을 읽고 있는데 도움이 됐어.

그래서 리사이즈 서비스와 스프링 클라우드 게이트를 활용한 `CDN`을 구축해봤어.

### 코루틴을 활용한 서버 구축

최근 코틀린을 학습하기도 했고


### 클라우드 게이트웨이를 활용한 CDN 구축

클라우드 게이트웨이를 활용해 `CDN`을 구축하기 위해서는 `ResponseCacheManager` 에 대한 이해가 필요했어.
`ResponseCacheManager#filter` 메서드 동작은 다음과 같아.

1. `GET` 요청이 있는지 확인한다.
2. 키를 활용해 캐시가 존재하는지 확인한다.
3. 캐시가 있을 때
    1. 동일한 요청 헤더 `Cache-control` 이 `no-cache`인 경우 `304`를 반환한다.
    2. 캐시가 있을 때 동일한 요청 헤더 `Cache-control` 이 `no-cache` 가 아닌 경우 게이트웨이에 저장된 응답 데이터를 반환한다.
    3. 캐시가 있을 때 동일한 요청 헤더 `Cache-control` 이 `no-stored`인 경우 원본을 가져온다.
4. 캐시가 없는 경우
    1. 캐싱 할 수 있는지 확인한다.
    2. 데이터를 캐싱한다.

어떤 값으로 캐시 데이터를 찾는지 궁금할거야 그래서 찾아봤어.
키를 저장 할 때 URI, 인증 정보, 쿠키 정보들로 비교하게 돼.

```java
public class CacheKeyGenerator {

	private final ThreadLocal<MessageDigest> messageDigest;

	/* for testing */ static final List<KeyValueGenerator> DEFAULT_KEY_VALUE_GENERATORS = List.of(
			new UriKeyValueGenerator(), new HeaderKeyValueGenerator(HttpHeaders.AUTHORIZATION, KEY_SEPARATOR),
			new CookiesKeyValueGenerator(KEY_SEPARATOR));

    //...
```

저장되는 키를 캡쳐 해봤어.

![그림 2](/static/images/project/fly-away-resized-image/1.png)

### 기술 트렌드 따라가는 일 재밌네...

- 요즘 새로운 기술들을 읽으면서 도입하고 있어. CDN이 필요했고 CDN에 저장되는 데이터를 직접 핸들링하는 일도 재밌어보였지.

