---
title: 상상까지 더 한 알림 시스템 개선기
date: '2024-09-20'
tags: ['프로젝트', '학습', '알림']
draft: false
summary: 애플리케이션과 데이터베이스만 활용해 확장 가능한 알림 서비스 구축기
images: []
---

<TOCInline toc={props.toc} exclude="Introduction"/>

## 서론

### 주제 이유

- 대량건 발송하기 위해 알림시 스템 개선 작업 필요하다.
- 단계적 성장을 모두 경험하기 어려우니 `요구 처리량`과 관계 없이 고민할 수 있을만큼 설계해보기 위해서 주제를 선정했다.

### 준비하게 된 계기

기능은 사용자가 1 명일 때와 1억 명인 경우 시스템 구조가 다르다.
나는 1명에서 1억명 사이 요청을 전달하는 알림 기능 성능 개선 과제를 맡았다.
과제를 하면서 요구사항에 맞게 성능 향상 경험은 얻을 수 있겠지만 그 이상은 쉽게 경험하기 어렵다.
이번 기회에 요구 처리량과 관계 없이 본인이 고민한 부분까지 시스템 개선을 모두 고려해보고 공유해볼 기회를 가져보려 한다.

### 목표

- 필요에 따라 쉽게 확장 가능했으면 좋겠다.
- 큐 시스템은 채택하지 않음 → 아집이지만 학습 목적이라 이해해주기 바란다.

### 가정

- 알림 발송 API는 알림 발송시 평균 5초 정도 소요되도록 설정해 알림 발송 기능에 최대한 부하를 많이 준다.
- 응답 중 10%는 서버 장애 이슈 10%는 잘못된 요청 이슈에 대응해보려 한다.

## 본론

### 알림 특징을 이용한 상태 변화 디자인

목표

- 프로젝트를 설계하면 객체가 생성되고 소멸되는 동적인 모든 상황들을 정적인 코드로 담아야 한다. 그렇기에 시간에 흐름에 따라 유연하게 변경이 가능하면서 동시에 모든 상황들을 대비할 수 있도록 견고하게 설계해야 한다.

알림 발송 기능은 다음과 같은 특징을 가진다.

- 알림은 한 명의 사용자에게 메시지를 전달한다.
- 알림은 하나의 메시지로 단체 발송이 가능하다.
- 알림은 상태에 따라 관리하는 방법이 다르다.
- 알림 정보는 변하지 않는다.

우린 추상화에 대해서 공부했다. 추상화를 통해 공통 요소를 줄이고 상태로 구분해 클래스 간 관계를 명확하게 정의할 수 있다.

> 추상화는 대상의 구체적인 형상이 아닌 점, 선, 면, 색 등 순수한 조형 요소로 표현한 미술의 한 가지 흐름이다.
> 자바에서 추상화는 공통된 특징을 묶고 공통되지 않은 특징을 분리해 반복되는 코드를 줄이고 객체 간 차이를 명확하게 가져간다.

알림은 상태만 변화하고 내부 정보는 변하지 않는 점을 고려한다면 다음처럼 객체 구성이 가능하다.

![그림 1](/static/images/project/design-notification-system/1.png)

객체지향은 객체 간 행동을 중심으로 생각하며 협력관계를 구축해 해당 역할에 들어가는 개체들의 자율성을 보장하게 된다.
덕분에 쉽게 교쳬 가능하다는 장점이 있다. 객체 지향에서는 행동도 객체가 될 수 있다.

행동이 객체로 표현된 클래스는 다음과 같다.
- StandbyNotification
- SendNotification
- CompleteNotification
- FailNotification
- FailbackNotification

행동의 결과물로 나오는 상태는 다음과 같다.

- RequestNotification
- PendingNotification
- SendingNotification
- CompletedNotification
- FailedNotification

- 참고하면 좋을 자료 : https://youtu.be/poPZvLi0O08?si=H1so9gPpggnElA1f
- 참고하면 좋을 자료 : https://m.yes24.com/Goods/Detail/18249021

알림 상태로 객체를 구분짓고 동적으로 변화하는 상태를 관리하기 위해 행동을 객체로 표현해 객체 간 협력 관계를 구축했다.
구축하면서 얻은 경험은 다음과 같다.

- 추상화
    - 장점 : 확장 가능성은 열 건 열고 막을 건 막을 수 있어 견고한 코드 구성이 가능하다.
    - 단점 : 공통 로직이 불변하지 않는나면 수정이 어렵다.
    - 특징 : 불변의 진리만이 추상화의 온전한 이점을 가질 수 있다.
- 객체 지향
    - 특징 : 객체 지향의 핵심은 구현이 아닌 협력 관계를 구축하는 데에 유연하고 견고하게 설계할 수 있다는 점이다.

# 단일 서버로 구현

단일 서버부터 출발해본다. `사용자가 적다면 가장 단순한 구현이 좋아보였고` 실행에 옮겼다. 알림 발송 건수가 적은 경우 설계는 다음과 같다.

![그림 4](/static/images/project/design-notification-system/4.png)

연결된 모든 클라이언트는 알림 발송이 완료될 때까지 대기하게 된다. 알림 발송이 늦어진다면 다음과 같은 이슈가 발생한다.

- 대기 시간이 길어질 수록 `read timeout`, `connection timeout`으로 인한 요청 실패에 노출될 가능성이 높아진다.
- 알림 발송 기능 장애가 클라이언트 측으로 전파된다.
- 클라이언트는 응답을 받기 위해 스레드를 대기(`TIMED_WAITING`) 상태로 유지하기 때문에 리소스 낭비가 존재한다.

알림 발송 기능으로 인한 장애 전파와 리소스 낭비를 줄이기 위해 클라이언트의 요청과 알림 발송 기능을 분리해봤다.

# 비동기로 사용자 요청과 알림 발송 요청 동작 분리

사용자 요청과 알림 전송을 비동기로 처리해 알림 전송에 따라 응답 시간이 의존되는 현상 해결한다. 비동기로 처리하면 다음과 같이 동작한다.

![그림 2](/static/images/project/design-notification-system/2.png)

이 때 알림 발송 요청 받으면 200 OK를 반환하게 된다. 즉, 알림 발송 요청은 무조건 전송되어야 한다는 뜻이다.
이런 경우 알림 발송 요청 행동의 부산물인 `PendingNotification`, `CompletedNotification`, `FailedNotification` 상태를 영속화한다면 사용자 요청을 보장할 수 있다.

![그림 3](/static/images/project/design-notification-system/3.png)

행동의 결과인 상태를 영속화하지 않는다면 서버는 상태를 가지고 있기 때문에 서버가 재시작되거나 종료되면 사용자 요청을 유실하게 된다.
데이터베이스 등과 같은 스토리지 시스템을 사용한다면 서버는 상태를 가지지 않게 되어 확장 또한 쉽다.

**해당 방식의 문제도 존재한다. 읽기는 빨라지지만 처리가 빨라지지는 않는다.**
알림 발송이 알림 발송 요청보다 처리양이 적은 경우 요청이 쌓일 수 있다.
요청수가 많아지면 빠르게 쌓이게 되지만 작업자는 처리할 수 있는 양이 한정된다.

![그림 5](/static/images/project/design-notification-system/5.png)

작업자가 처리할 수 있는 양을 높일 방법은 작업자를 늘리는 방법이 있다.

# WebClient로 사용자 요청 처리하기

알림 발송 대기 상태로 메모리를 점유하는 현상을 해결하기 위해서는 요청 마다 스레드를 생성하지 않아야 한다.
현재까지 `RestClient`로 작업을 처리하기 위해 알림 발송 요청 묶음만큼 스레드를 직접 생성하고 `RestClient`를 이용해 요청을 전송하도록 위임했다.

요청마다 스레드를 직접 생성하는건 낭비다. 그만큼 응답이 올때까지 대기하는 스레드가 늘어난다는 의미다.

![그림 8](/static/images/project/design-notification-system/8.png)

`WebClient`를 이용한다면 요청마다 스레드를 생성하지 않고 요청을 처리할 수 있다.
`WebClient` 내부에서 스레드 풀을 이용해 요청을 보내고 응답 신호가 오면 응답을 받아 전달하게 된다.

![그림 9](/static/images/project/design-notification-system/9.png)

`WebClient`는 요청을 보낼따마다 스레드를 생성한다면 리소스 낭비를 극복할 수 있도록 도와준다.
`WebClient` 단점은 `Webflux`와 같은 Reactive 라이브러리가 의존성에 추가되어야 한다는 점이다.
`WebClient`를 사용하기 위해 `Webflux` 의존성 추가는 자유도를 높이는 일이고 의도하지 않은 사용도 존재할 테니 조심스럽다.

# 알림 전송 병렬처리 수행

많아진 알림 발송 전송을 처리하기 위해서는 작업자를 늘릴 수 있어야 한다.
기존에는 스토리지에서 보낼 데이터를 청크 단위로 꺼내 전송했다.

![그림 6](/static/images/project/design-notification-system/6.png)

병렬처리 수행하기 위해 어떤 위치부터 수행할지 파악할 수 있는 카운팅 공유 데이터를 만들었다.
특정 작업자가 대기상태알림을 조회하면 카운팅을 읽으만큼 증가시키면 다음 작업자는 다음 칸 대기상태알림을 조회한다.
특정 작업자가 알림을 전송하면 기존 데이터를 지우고 지운 만큼 카운팅을 감소시킨다.

![그림 7](/static/images/project/design-notification-system/7.png)

이렇게 공유 데이터로 읽어야 할 위치를 서로 공유한다면 문제 없이 병렬처리가 가능하다.

병렬 처리 이점은 멀티 인스턴스로 쉽게 확장 가능하다는 점이다. 확장이 가능하다면 단일 서버 형태만 가지는 리소스 낭비를 줄일 수 있다.

> 파편화로 예시를 듣나면 파편화 크기가 적을 수록 리소스 오남용이 적어진다.
> 서버 리소스를 줄요 멀티 인스턴스로 관리한다면 트래픽에 맞게 리소스 활용이 가능하다.

![그림 10](/static/images/project/design-notification-system/10.png)

공유 데이터를 외부에서 관리한다면 다음처럼 멀티 인스턴스로 구성할 수 있다.

![그림 11](/static/images/project/design-notification-system/11.png)

병렬 처리 덕분에 다음과 같은 장점을 가질 수 있었다.

- 처리율을 원하는 만큼 높일 수 있다.
- 멀티 인스턴스로 쉽게 변경 가능하다.

반면 작업자가 많아지면서 스토리지 부하가 많아질테다. 스토리지 부하 이슈에 대한 대응이 필요하다.

# 저장소 스케일링 진행

스토리지 부하 분산을 위해 저장소 스케일링 진행이 필요하다.
알림 발송 서버가 멀티 인스턴스로 구축되면서 저장소에 접근하는 빈도가 많아지게 된다.

![그림 12](/static/images/project/design-notification-system/12.png)

스토리지를 스케일링 한다면 알림 서버가 증설되는 상황에 쉽게 대응 할 수 있다.
필자는 간단하게 모듈러 연산으로 샤딩을 수행했다.

![그림 13](/static/images/project/design-notification-system/13.png)

이 때 모듈러 연산에 사용할 키워드 선정이 매우 중요하다.
만약 사용자 식별자로 모듈러 연산을 진행한다면 다음과 같은 이점과 단점이 있다.

- 이점
  - 동일한 사용자는 동일한 스토리지에 저장되므로 알림 발송 요청 순서에 맞게 전송할 수 있다.
- 단점
  - 동일한 사용자는 동일한 스토리지에 저장되므로 핫키 문제가 발생한다.

모듈러 연산으로 저장할 때 특정 키워드로 동일한 스토리지를 유지해야 하는 경우에는 해당 키워를 활용하는게 좋다.
반면 핫 키 문제를 해결해야 할 과제다.


