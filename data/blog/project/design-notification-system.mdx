---
title: 상상까지 더 한 알림 시스템 개선기
date: '2024-09-20'
tags: ['프로젝트', '학습', '알림']
draft: false
summary: 애플리케이션과 데이터베이스만 활용해 확장 가능한 알림 서비스 구축기
images: []
---

<TOCInline toc={props.toc} exclude="Introduction"/>

## 서론

### 주제 이유

- 대량건 발송하기 위해 알림시 스템 개선 작업 필요하다.
- 단계적 성장을 모두 경험하기 어려우니 `요구 처리량`과 관계 없이 고민할 수 있을만큼 설계해보기 위해서 주제를 선정했다.

### 준비하게 된 계기

기능은 사용자가 1 명일 때와 1억 명인 경우 시스템 구조가 다르다.
나는 1명에서 1억명 사이 요청을 전달하는 알림 기능 성능 개선 과제를 맡았다.
과제를 하면서 요구사항에 맞게 성능 향상 경험은 얻을 수 있겠지만 그 이상은 쉽게 경험하기 어렵다.
이번 기회에 요구 처리량과 관계 없이 본인이 고민한 부분까지 시스템 개선을 모두 고려해보고 공유해볼 기회를 가져보려 한다.

### 목표

- 필요에 따라 쉽게 확장 가능하도록 구성한다.
- 학습 목적이기 때문에 곧바로 큐 시스템을 채택하지 않았다.

## 본론

### 알림 특징을 이용한 상태 변화 디자인

목표

- 프로젝트를 설계하면 객체가 생성되고 소멸되는 동적인 모든 상황들을 정적인 코드로 담아야 한다. 그렇기에 시간에 흐름에 따라 유연하게 변경이 가능하면서 동시에 모든 상황들을 대비할 수 있도록 견고하게 설계해야 한다.

알림 발송 기능은 다음과 같은 특징을 가진다.

- 알림은 한 명의 사용자에게 메시지를 전달한다.
- 알림은 하나의 메시지로 단체 발송이 가능하다.
- 알림은 상태에 따라 관리하는 방법이 다르다.
- 알림 정보는 변하지 않는다.

우린 추상화에 대해서 공부했다. 추상화를 통해 공통 요소를 줄이고 상태로 구분해 클래스 간 관계를 명확하게 정의할 수 있다.

> 추상화는 대상의 구체적인 형상이 아닌 점, 선, 면, 색 등 순수한 조형 요소로 표현한 미술의 한 가지 흐름이다.
> 자바에서 추상화는 공통된 특징을 묶고 공통되지 않은 특징을 분리해 반복되는 코드를 줄이고 객체 간 차이를 명확하게 가져간다.

알림은 상태만 변화하고 내부 정보는 변하지 않는 점을 고려한다면 다음처럼 객체 구성이 가능하다.

![그림 1](/static/images/project/design-notification-system/1.png)

객체지향은 객체 간 행동을 중심으로 생각하며 협력관계를 구축해 해당 역할에 들어가는 개체들의 자율성을 보장하게 된다.
덕분에 쉽게 교쳬 가능하다는 장점이 있다. 객체 지향에서는 행동도 객체가 될 수 있다.

행동이 객체로 표현된 클래스는 다음과 같다.
- StandbyNotification
- SendNotification
- CompleteNotification
- FailNotification
- FailbackNotification

행동의 결과물로 나오는 상태는 다음과 같다.

- RequestNotification
- PendingNotification
- SendingNotification
- CompletedNotification
- FailedNotification

![그림 0](/static/images/project/design-notification-system/0.png)

- 참고하면 좋을 자료 : https://youtu.be/poPZvLi0O08?si=H1so9gPpggnElA1f
- 참고하면 좋을 자료 : https://m.yes24.com/Goods/Detail/18249021

알림 상태로 객체를 구분짓고 동적으로 변화하는 상태를 관리하기 위해 행동을 객체로 표현해 객체 간 협력 관계를 구축했다.
구축하면서 얻은 경험은 다음과 같다.

- 추상화
    - 장점 : 확장 가능성은 열 건 열고 막을 건 막을 수 있어 견고한 코드 구성이 가능하다.
    - 단점 : 공통 로직이 불변하지 않는나면 수정이 어렵다.
    - 특징 : 불변의 진리만이 추상화의 온전한 이점을 가질 수 있다.
- 객체 지향
    - 특징 : 객체 지향의 핵심은 구현이 아닌 협력 관계를 구축하는 데에 유연하고 견고하게 설계할 수 있다는 점이다.

### 단일 서버로 구현

단일 서버부터 출발해본다. `사용자가 적다면 가장 단순한 구현이 좋아보였고` 실행에 옮겼다. 알림 발송 건수가 적은 경우 설계는 다음과 같다.

![그림 4](/static/images/project/design-notification-system/4.png)

연결된 모든 클라이언트는 알림 발송이 완료될 때까지 대기하게 된다. 알림 발송이 늦어진다면 다음과 같은 이슈가 발생한다.

- 대기 시간이 길어질 수록 `read timeout`, `connection timeout`으로 인한 요청 실패에 노출될 가능성이 높아진다.
- 알림 발송 기능 장애가 클라이언트 측으로 전파된다.
- 클라이언트는 응답을 받기 위해 스레드를 대기(`TIMED_WAITING`) 상태로 유지하기 때문에 리소스 낭비가 존재한다.

알림 발송 기능으로 인한 장애 전파와 리소스 낭비를 줄이기 위해 클라이언트의 요청과 알림 발송 기능을 분리해봤다.

### 장애 전파 문제 해결 : 비동기로 사용자 요청과 알림 발송 요청 동작 분리

사용자 요청과 알림 전송을 비동기로 처리해 알림 전송에 따라 응답 시간이 의존되는 현상 해결한다. 비동기로 처리하면 다음과 같이 동작한다.

![그림 2](/static/images/project/design-notification-system/2.png)

이 때 알림 발송 요청 받으면 200 OK를 반환하게 된다. 즉, 알림 발송 요청은 무조건 전송되어야 한다는 뜻이다.
이런 경우 알림 발송 요청 행동의 부산물인 `PendingNotification`, `CompletedNotification`, `FailedNotification` 상태를 영속화한다면 사용자 요청을 보장할 수 있다.

![그림 3](/static/images/project/design-notification-system/3.png)

행동의 결과인 상태를 영속화하지 않는다면 서버는 상태를 가지고 있기 때문에 서버가 재시작되거나 종료되면 사용자 요청을 유실하게 된다.
데이터베이스 등과 같은 스토리지 시스템을 사용한다면 서버는 상태를 가지지 않게 되어 확장 또한 쉽다.

작은 그림으로 살펴보자. 우린 의도한대로 알림 발송 요청과 사용자 요청을 분리해 처리할 수 있게 되었다.
그러나 사용자 요청을 봤을 때 한 건 처리할 때마다 5초 걸리는 건 사실이다.

![그림 14](/static/images/project/design-notification-system/14.png)

사용자 요청은 영속화되어 관리되고 알림 발송 요청은 비동기로 처리되어 사용자 요청에 영향을 주지 않는다.
우리가 원하는대로 알림 발송으로 인해 사용자 요청이 유실될 가능성을 줄였지만 작업자의 전송량에 따라 알림 발송 처리량이 결정된다.

알림 발송 응답을 대기하지 않고 지속적으로 요청한다면 처리량을 높일 수 있지 않을까?

### 전송량 문제 해결 : 비동기로 요청 기다리지 않고 대량 발송하기

알림 발송 요청을 대기하지 않고 새롭게 스레드를 생성해 알림 발송 요청한다면 처리량을 높일 수 있다.

![그림 15](/static/images/project/design-notification-system/15.png)

**해당 방식의 문제도 존재한다. 읽기는 빨라지지만 처리가 빨라지지는 않는다.**
알림 발송이 알림 발송 요청보다 처리양이 적은 경우 요청이 쌓일 수 있다.
요청수가 많아지면 빠르게 쌓이게 되지만 작업자는 처리할 수 있는 양이 한정된다.

![그림 5](/static/images/project/design-notification-system/5.png)

요청을 보낼따마다 스레드를 생성한다면 리소스 낭비다. 이 문제를 해결하기 위해 `WebClient`를 사용해보자.

### 리소스 낭비 문제 해결 : WebClient로 사용자 요청 처리하기

알림 발송 대기 상태로 메모리를 점유하는 현상을 해결하기 위해서는 요청 마다 스레드를 생성하지 않아야 한다.
현재까지 `RestClient`로 작업을 처리하기 위해 알림 발송 요청 묶음만큼 스레드를 직접 생성하고 `RestClient`를 이용해 요청을 전송하도록 위임했다.

요청마다 스레드를 직접 생성하는건 낭비다. 그만큼 응답이 올때까지 대기하는 스레드가 늘어난다는 의미다.

![그림 8](/static/images/project/design-notification-system/8.png)

`WebClient`를 이용한다면 요청마다 스레드를 생성하지 않고 요청을 처리할 수 있다.
`WebClient` 내부에서 스레드 풀을 이용해 요청을 보내고 응답 신호가 오면 응답을 받아 전달하게 된다.

![그림 9](/static/images/project/design-notification-system/9.png)

`WebClient`는 요청을 보낼따마다 스레드를 생성한다면 리소스 낭비를 극복할 수 있도록 도와준다.
`WebClient` 단점은 `Webflux`와 같은 Reactive 라이브러리가 의존성에 추가되어야 한다는 점이다.
`WebClient`를 사용하기 위해 `Webflux` 의존성 추가는 자유도를 높이는 일이고 의도하지 않은 사용도 존재할 테니 조심스럽다.

한 대의 서버로는 처리량과 가용성의 한계가 존재한다. 이를 해결하기 위해 멀티 인스턴스로 구성해보자.

![그림 10](/static/images/project/design-notification-system/10.png)

### 처리량 한계 문제 해결 : 멀티 인스턴스 구성

공유 데이터를 외부에서 관리한다면 다음처럼 멀티 인스턴스로 구성할 수 있다.

![그림 11](/static/images/project/design-notification-system/11.png)

많아진 알림 발송 전송을 처리하기 위해서는 작업자를 늘릴 수 있어야 한다.
기존에는 스토리지에서 보낼 데이터를 청크 단위로 꺼내 전송했다.

![그림 6](/static/images/project/design-notification-system/6.png)

병렬처리 수행하기 위해 어떤 위치부터 수행할지 파악할 수 있는 카운팅 공유 데이터를 만들었다.
특정 작업자가 대기상태알림을 조회하면 카운팅을 읽으만큼 증가시키면 다음 작업자는 다음 칸 대기상태알림을 조회한다.
특정 작업자가 알림을 전송하면 기존 데이터를 지우고 지운 만큼 카운팅을 감소시킨다.

![그림 7](/static/images/project/design-notification-system/7.png)

이렇게 공유 데이터로 읽어야 할 위치를 서로 공유한다면 문제 없이 병렬처리가 가능하다.

병렬 처리 이점은 멀티 인스턴스로 쉽게 확장 가능하다는 점이다. 확장이 가능하다면 단일 서버 형태만 가지는 리소스 낭비를 줄일 수 있다.

> 파편화로 예시를 듣나면 파편화 크기가 적을 수록 리소스 오남용이 적어진다.
> 서버 리소스를 줄요 멀티 인스턴스로 관리한다면 트래픽에 맞게 리소스 활용이 가능하다.

병렬 처리 덕분에 다음과 같은 장점을 가질 수 있었다.

- 처리율을 원하는 만큼 높일 수 있다.
- 멀티 인스턴스로 쉽게 변경 가능하다.

반면 작업자가 많아지면서 스토리지 부하가 많아질테다. 스토리지 부하 이슈에 대한 대응이 필요하다.

### 스토리지 부하 문제 해결 : 스토리지 스케일링 진행

스토리지 부하 분산을 위해 저장소 스케일링 진행이 필요하다.
알림 발송 서버가 멀티 인스턴스로 구축되면서 저장소에 접근하는 빈도가 많아지게 된다.

![그림 12](/static/images/project/design-notification-system/12.png)

스토리지를 스케일링 한다면 알림 서버가 증설되는 상황에 쉽게 대응 할 수 있다.
필자는 간단하게 모듈러 연산으로 샤딩을 수행했다.

![그림 13](/static/images/project/design-notification-system/13.png)

이 때 모듈러 연산에 사용할 키워드 선정이 매우 중요하다.
만약 사용자 식별자로 모듈러 연산을 진행한다면 다음과 같은 이점과 단점이 있다.

- 이점
  - 동일한 사용자는 동일한 스토리지에 저장되므로 알림 발송 요청 순서에 맞게 전송할 수 있다.
- 단점
  - 동일한 사용자는 동일한 스토리지에 저장되므로 특정 데이터베이스에만 저장과 조회가 집중되는 핫키 현상이 발생한다.

모듈러 연산으로 저장할 때 특정 키워드로 동일한 스토리지를 유지해야 하는 경우에는 해당 키워를 활용하는게 좋다.
반면 핫 키 문제를 해결해야 할 과제다.

### 핫키 문제 해결 : 중복도 낮추기

핫키를 해결하기 위해서 키워드를 고르게 분산해야 한다. 즉, 특정 키워드를 모듈러 연산한 결과 값의 중복된 수치가 적을수록 핫키 문제를 줄일 수 있다.

- 특정 키워드의 중복도를 낮춘다.
    - 만약 한 사용자에 대한 순차적인 처리를 보장하고 싶었다면 분 단위 전송 시간과 사용자 식별자를 조합해 모듈러 연산을 진행하면서 중복된 수치를 줄일 수 있다.
- 가상 노드를 활용한 해시링을 사용한다.
    - 해시링은 스토리지 스케일링에 대응하기 쉽게 나온 개념이다. 해시링의 단점은 데이터가 균등하게 분포하지 못한다는 점인데, 가상 노드를 활용한다면 균등하게 분포할 수 있다.

상황에 맞게 둘 중 하나를 사용한다면 핫키 문제를 해결할 수 있다.
스토리지 스케일링이 빈번하다면 해시링을 활용하는게 좋겠지만 그렇지 않다면 단순하게 특정 키워드에 대한 중복도를 낮춘느게 방법이다.

전송 완료 이력을 특정 주기로 백업한다면 해시링까지 구현할 필요가 없다.

## 결론

### 회고

- 시스템 추가는 쉽지만 수정은 어렵다. 시스템 추가에 신중한 편이라 기존 시스템으로 해결 가능하다면 해결하는 편이다.
- 객체지향은 객체 간 행동을 중심으로 생각하며 협력관계를 구축해 해당 역할에 들어가는 객체들의 자율성을 보장하게 된다. 행동을 중심으로 상태 변화를 캐치해 객체들의 자율성을 보장하는 환경을 경험할 수 있었다.
- 구현하면서 느낀점은 대기 상태 알림을 전송하는 과정에서 push, pull 동작을 수행하는 스토리지를 사용하면 쉽게 구현할 수 있어보였다. 괜찮다면 RabbitMQ와 같은 큐 시스템을 사용해 개선하면 좋아보인다.

